<!DOCTYPE html>
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .cButton {
            width: 80px;
            height: 20px;
            margin:2px;
        }

        #temperature {
            padding: 5px;
            width: 470px;
            font-size: 1.2em;
            text-align: left;
        }
    </style>
    <script>
    var warn_audio = new Audio('warningSFX.mp3');

    function heatMapColorforValue(value,low=0,middle=0.5,high=1){
      if(value>high)value=high;
      if(value<low)value=low;
      var ratio;
      if(value<middle)
        ratio = 0.5*(value-low)/(middle-low);
      else
        ratio = 0.5+0.5*(value-middle)/(high-middle);

      // var h = ((ratio-0.5)*1.2)+0.5;
      // if(h>1)h=1;
      // if(h<0)h=0;
      var h = ((0.5-ratio)*1.2)+0.5;
      if(h>1)h=1;
      if(h<0)h=0;

      h=h*240;
      var s = 100;
      var l = 10+50*(Math.sqrt(Math.sin(ratio*Math.PI)));


      return "hsl(" + h + ","+s+"%,"+l+"%)";
    }


    function heatMapColorforValue2(value, avgLowTemp, avgHighTemp) {
        if(value>avgHighTemp)value=avgHighTemp;
        if(value<avgLowTemp)value=avgLowTemp;
        let h;
        let l = 50;
        let s;
        let a = 1;
        let threshold = 38;
        let diff = avgHighTemp - avgLowTemp;
        if (diff < 4) {
            if (avgHighTemp < 75) {
                threshold = 100 - (diff * 4);
            } else if(avgHighTemp > 75) {
                threshold = (diff * 4);
            }
        }
        if (value < threshold) {//35) {
            h = 200 + (1.0 - (value / threshold)) * 30;
            l = 50 + (value / threshold) * 30;
            s = 60 + (value / threshold) * 35;
            a = 0.8;
        } else {
            h = 10 + 40 * (1.0 - ((value - threshold) / threshold));
            l = 40 + 50 * (1.0 - ((value - threshold) / threshold));//50 * (1.0 - ((value - threshold) / threshold)) + 50;
            s = 98;
            a = 0.95;
        }
        return `hsla( ${h}, ${s}%, ${l}%, ${a})`;
    }

    function percentToRGB(percent) {
        if (percent === 100) {
            percent = 99
        }
        var r, g, b;
        var result = '';
        if (percent < 50) {
            // blue to yellow
            r = Math.floor(255 * ((percent - 30) / 20));//Math.floor(255 * ((50 - percent % 50) / 100));
            g = Math.floor(180 * ((percent) / 50));//Math.floor(80 * ((65 - percent) / 50));;//Math.floor(200 * (percent / 50) - 50);//Math.floor(255 * (percent / 100));//Math.floor(255 * (percent / 50));;
            b = Math.floor(255 * ((75 - percent) / 50));
            result = 'rgba(' + r + ',' + g + ',' + b + ', 0.9)';
        } else {
            // yellow to red
            r = 255;
            g = Math.floor(200 * ((50 - percent % 50) / 50));
            b = Math.floor(100 * ((50 - percent % 50) / 50));//0;
            result = 'rgba(' + r + ',' + g + ',' + b + ', 0.9)';
        }
        return result;
    }

    function interpolateData(input, rowLength) {
        const output = [];
        let rowNum = 1;
        for (let n = 0; n < input.length; n += 1) {
            //output.push(n % rowLength);
            if (n % rowLength === 0) {
                output.push((input[n] + input[n + 1]) / 2)            
            } else if (n > 0) {
                output.push((input[n] + input[n - 1]) / 2)
            } else {
                output.push(input[n]);
            }
            
            if ((n + 1) % rowLength === 0) {
                if (input.length - n > rowLength) {
                    for (let r = 1; r <= rowLength * 2 - 1; r++) {
                        const roundedA = ((rowNum - 1) * rowLength) + Math.floor((r - 1) / 2);
                        const roundedB = ((rowNum - 1) * rowLength) + Math.floor((r - 1) / 2);
                        const topA = input[roundedA];
                        const topB = input[roundedB];
                        const roundedC = (rowNum * rowLength) + Math.floor((r - 1) / 2);
                        const roundedD = (rowNum * rowLength) + Math.floor((r - 1) / 2);
                        const bottomA = input[roundedC];
                        const bottomB = input[roundedD];
                        //output.push(0);
                        output.push((topA + topB + bottomA + bottomB) / 4);
                    }
                    rowNum += 1;
                }
                // Do nothing
            } else {
                //output.push(0);
                output.push((input[n] + input[n + 1]) / 2)
            }
        }
        return output;
    }

    function stringPadZero(str,zeros)
    {
      while(str.length<zeros)
      {
        str="0"+str;
      }
      return str;
    }

    function numberFormat(num)
    {
      let pp=1;
      let points=Math.pow(10,pp);
      let xK=Math.round(num*points);
      let point=(xK%points)+"";
      
      let dig=Math.floor(xK/points)+"";
      return stringPadZero(dig,2)+"."+stringPadZero(point,pp);
    }
    
    let mixPix=undefined;
    let warnAudioPlay=false;
    let frame_counter = 0;
    let connection=undefined;
    let warnFrame=undefined;
    let pixSize=5;
    let xflip=false;
    let rotateIdx=0;
    let filterMode=0;
    // Log messages from the server
    let onmessage = function (e) {
        if (e.data.length < 100) {
            return;
        }
        frame_counter += 1;
        const values_raw = new Int16Array(e.data);
        if(mixPix===undefined)
        {
          mixPix= new Array(values_raw.length);
          values_raw.forEach((mP,idx) => {
            mixPix[idx]=1.0*mP;
          });
          
          
        }
        else
        {
          switch(filterMode)
          {
            case 0:
              values_raw.forEach((mP,idx) => {
                mixPix[idx]=1.0*mP;
              });
              break;
            
            case 1:
              mixPix.forEach((mP,idx) => {
                let diff = values_raw[idx]-mP;
                if(diff<0)diff=-diff;
                diff-=50;
                let approachV=diff/100;
                if(approachV>1)approachV=1;
                if(approachV<0.2)approachV=0.2;
                mixPix[idx]+=approachV*(values_raw[idx]-mP);
              });
              break;
            
            case 2:
              
              mixPix.forEach((mP,idx) => {
                if(values_raw[idx]>mP)
                {
                  mixPix[idx]=values_raw[idx];
                  return;
                }
                let approachV=0.05;
                mixPix[idx]+=approachV*(values_raw[idx]-mP);
              });

              break;

            case 3:
              
              
              let rmse = Math.sqrt(
                mixPix.reduce((s,v,idx)=>
                  s+(v-values_raw[idx])*(v-values_raw[idx]),0)/mixPix.length
                  );
              
              rmse-=70;

              rmse/=70;

              if(rmse>1)rmse=1;
              if(rmse<0.1)rmse=0.1;
              let approachV=rmse;
              mixPix.forEach((mP,idx) => {
                let tmpap=approachV;
                if(values_raw[idx]>mP)
                {
                  tmpap=1;
                }
                mixPix[idx]+=tmpap*(values_raw[idx]-mP);
              });
              break;
          }
        }

        const values=mixPix.map(v=>((v/100.0)*36.4/30));
        const tempValues = interpolateData(values, 32);
        const sortedValues = values.slice().sort();
        // console.log(values);
        let avgHighTemp = 0;
        let avgLowTemp = 0;
        
        let avgTemp = sortedValues.reduce((s,v)=>s+v,0)/sortedValues.length;

        let highCount=4;
        for (let w = sortedValues.length - 1; w > sortedValues.length - 1-highCount; w -= 1) {
            avgHighTemp += sortedValues[w];
        }
        avgHighTemp = avgHighTemp / highCount;

        avgLowTemp = 0;

        let lowCount=20;
        for (let w = 0; w < lowCount; w += 1) {
            avgLowTemp += sortedValues[w+4];
        }
        avgLowTemp = avgLowTemp / lowCount;
        
        document.getElementById('temperature').innerText = 
          'H: ' + numberFormat(avgHighTemp) + ' C | L: ' +  numberFormat(avgLowTemp)  + 
          ' C \n AVG: ' + numberFormat(avgTemp) + ' C';
    

        let high = 40;
        let low = 20;

        var c2 = document.getElementById('myCanvas');
        var c2_context = c2.getContext('2d');
        c2_context.font = "40pt Arial";
        let heatMapBarW=10;
        switch(rotateIdx)
        {
          case 0:
          case 2:
            c2.height=(64*pixSize)|0;
            c2.width=((48*pixSize)|0)+heatMapBarW;
          break;
          case 1:
          case 3:

            c2.width=((64*pixSize)|0)+heatMapBarW;
            c2.height=(48*pixSize)|0;
          break;

        }

        for (let i = 0; i < tempValues.length; i += 1) {

            let drawStroke=false;
            
            if(tempValues[i]>37.5)
            {
              
              if(warnAudioPlay && warnFrame===undefined)
              {
                warnFrame=frame_counter;
                warn_audio.play();
              }
              c2_context.strokeStyle = "#00FFFF";
              drawStroke=true;
            }
            else
            {
              if(warnFrame!==undefined)
              {
                if(frame_counter-warnFrame>40)
                {
                  warnFrame=undefined;
                  warn_audio.pause();
                }
              }
            }
            let value = (tempValues[i] - low) / (high - low);
            c2_context.fillStyle = heatMapColorforValue(value);
            // c2_context.fillStyle = heatMapColorforValue2(tempValues[i],low,high);

            

            let xpos = (i/63)| 0;
            let ypos = i%63;
            let xPos;
            let yPos;
            switch(rotateIdx)
            {
              case 0:
                xPos=xpos;
                yPos= ypos;
              break;
              case 1:
                xPos=ypos;
                yPos=46-xpos;
              break;
              case 2:
                xPos=46-xpos;
                yPos=62-ypos;
              break;
              case 3:
                yPos=xpos;
                xPos=62-ypos;
              break;

            }
            // console.log(xPos,yPos);
            if(xflip==true)
            {
              switch(rotateIdx)
              {
                case 0:
                case 2:
                  xPos=46-xPos;
                break;
                case 1:
                case 3:
                  xPos=62-xPos;
                break;
              }
            }

            c2_context.fillRect(xPos*pixSize, yPos*pixSize, pixSize, pixSize);
            if(drawStroke)
              c2_context.strokeRect(xPos*pixSize, yPos*pixSize, pixSize, pixSize);
        }

        let drawBlockH=20;
        for (let i = 0; i < c2.height; i += drawBlockH)
        {
          
          c2_context.fillStyle = heatMapColorforValue((c2.height-i)/c2.height);
          c2_context.fillRect(c2.width-heatMapBarW, i, heatMapBarW, drawBlockH);
        }
        
        for (let i = 0; i < c2.height; i += drawBlockH*5)
        {
          
          c2_context.fillStyle = heatMapColorforValue((c2.height-i)/c2.height);
          c2_context.fillRect(c2.width-heatMapBarW, i, heatMapBarW, drawBlockH);
        }
        c2_context.fillStyle = "#FFF";
        c2_context.fillText(high, c2.width-10,20);
        c2_context.fillText(low, c2.width-10,c2.height-10);

    };
    function ws_start()
    {
      if(connection!==undefined)
      {
        ws_stop();
      }
      let input_IP_DOM=document.getElementById('input_IP');
      let start_btn_DOM=document.getElementById('start_btn');
      input_IP_DOM.disabled=true;
      start_btn_DOM.disabled=true;
      let url = 'ws://'+input_IP_DOM.value;

      connection= new WebSocket(url);

      connection.binaryType = "arraybuffer";
      connection.onopen = function () {
        connection.send('Ping'); // Send the message 'Ping' to the server
      };
      connection.onclose = function(event) {
        input_IP_DOM.disabled=
        start_btn_DOM.disabled=false;
        connection=undefined;
        
        warn_audio.pause();
      };
      // Log errors
      connection.onerror = function (error) {
        console.log('WebSocket Error ' + error);
        input_IP_DOM.disabled=
        start_btn_DOM.disabled=false;
        connection=undefined;
        warn_audio.pause();
      };
      connection.onmessage=onmessage;
    }
    function ws_stop()
    {
      
      if(connection==undefined)
      {
        return;
      }
      connection.close();
    }

    function rotate() {
      rotateIdx=(rotateIdx+1)%4;
    }
    function FilterMode_toggle() {
      filterMode=(filterMode+1)%4;
      
      document.getElementById('filterMode_btn').innerText = "Filter:"+filterMode;
    }

    
    function flipX() {
      xflip=!xflip;
    }

    function SOUND_toggle()
    {
      warnAudioPlay=!warnAudioPlay;
      warn_audio.pause();
      
      document.getElementById('sound_btn').innerText = "SOUND:"+(warnAudioPlay?"ON":"OFF");
    }
    </script>
</head>
<body>
    <canvas id='myCanvas' height='480' width='640' style='border:1px solid #d3d3d3;'></canvas>
    <p id='temperature'></p>
    <button class="cButton" onclick='flipX()'>Flip X</button>
    <button class="cButton" onclick='rotate()'>ROTATE</button>
    <br/>
    <button  class="cButton" onclick='ws_stop()'  id="stop_btn">STOP</button>
    <button  class="cButton" onclick='SOUND_toggle()'  id="sound_btn">SOUND:OFF</button>
    <button  class="cButton" onclick='FilterMode_toggle()'  id="filterMode_btn">Filter:0</button>
    <br/>
    <input type="text" id="input_IP" name="input_IP" value="thermal.local:81">
    <button class="cButton" onclick='ws_start()'  id="start_btn">START</button>
</body>
</html>