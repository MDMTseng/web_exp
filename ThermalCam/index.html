<!DOCTYPE html>
<html lang='en'  manifest="cache.manifest">

<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        .fullFrame {
            width: 100%;
            height: 100%;
        }
        .cButton {
            width: 80px;
            height: 30px;
            margin:1px;
        }

        .sButton {
            width: 10px;
            height: 30px;
            margin:0px;
        }
        #temperature {
            padding: 5px;
            font-size: 1.2em;
            text-align: left;
        }
        .left {
          float:left;
        }
        .right {
          width: 100%;
          height:100%;
        }
    </style>

    <script>
      // // Register the service worker
      // if ('serviceWorker' in navigator) {
      //   navigator.serviceWorker.register('./service-worker.js').then(function(registration) {
      //     // Registration was successful
      //     console.log('ServiceWorker registration successful with scope: ', registration.scope);
      // }).catch(function(err) {
      //     // registration failed :(
      //       console.log('ServiceWorker registration failed: ', err);
      //     });
      // }
    </script>
    <script>


    function ls_setCamUrl(url)
    {
      return localStorage.setItem("ThermalCamUrl",url);
    }
    function ls_getCamUrl()
    {
      return localStorage.getItem("ThermalCamUrl");
    }


    
    function ls_setJson(key,data)
    {
      return localStorage.setItem(key,JSON.stringify(data));
    }
    function ls_getJson(key)
    {
      let str = localStorage.getItem(key);
      if(str===undefined || str===null)return undefined;
      try {
        return JSON.parse(str);
      } catch (e) {
      }
      return undefined;
    }


    var warn_audio = new Audio('warningSFX.mp3');

    function heatMapColorforValue(value,low=0,middle=0.5,high=1){
      if(value>high)value=high;
      if(value<low)value=low;
      var ratio;
      if(value<middle)
        ratio = 0.5*(value-low)/(middle-low);
      else
        ratio = 0.5+0.5*(value-middle)/(high-middle);

      // var h = ((ratio-0.5)*1.2)+0.5;
      // if(h>1)h=1;
      // if(h<0)h=0;
      var h = ((0.5-ratio)*1.2)+0.5;
      if(h>1)h=1;
      if(h<0)h=0;

      h=h*240;
      var s = 100;
      var l = 10+50*(Math.sqrt(Math.sin(ratio*Math.PI)));


      return "hsl(" + h + ","+s+"%,"+l+"%)";
    }

    function url_setDefault()
    {
      
      let input_IP_DOM=document.getElementById('input_IP');
      input_IP_DOM.value="thermal.local:81";
    }


    function heatMapColorforValue2(value, avgLowTemp, avgHighTemp) {
        if(value>avgHighTemp)value=avgHighTemp;
        if(value<avgLowTemp)value=avgLowTemp;
        let h;
        let l = 50;
        let s;
        let a = 1;
        let threshold = 38;
        let diff = avgHighTemp - avgLowTemp;
        if (diff < 4) {
            if (avgHighTemp < 75) {
                threshold = 100 - (diff * 4);
            } else if(avgHighTemp > 75) {
                threshold = (diff * 4);
            }
        }
        if (value < threshold) {//35) {
            h = 200 + (1.0 - (value / threshold)) * 30;
            l = 50 + (value / threshold) * 30;
            s = 60 + (value / threshold) * 35;
            a = 0.8;
        } else {
            h = 10 + 40 * (1.0 - ((value - threshold) / threshold));
            l = 40 + 50 * (1.0 - ((value - threshold) / threshold));//50 * (1.0 - ((value - threshold) / threshold)) + 50;
            s = 98;
            a = 0.95;
        }
        return `hsla( ${h}, ${s}%, ${l}%, ${a})`;
    }

    function percentToRGB(percent) {
        if (percent === 100) {
            percent = 99
        }
        var r, g, b;
        var result = '';
        if (percent < 50) {
            // blue to yellow
            r = Math.floor(255 * ((percent - 30) / 20));//Math.floor(255 * ((50 - percent % 50) / 100));
            g = Math.floor(180 * ((percent) / 50));//Math.floor(80 * ((65 - percent) / 50));;//Math.floor(200 * (percent / 50) - 50);//Math.floor(255 * (percent / 100));//Math.floor(255 * (percent / 50));;
            b = Math.floor(255 * ((75 - percent) / 50));
            result = 'rgba(' + r + ',' + g + ',' + b + ', 0.9)';
        } else {
            // yellow to red
            r = 255;
            g = Math.floor(200 * ((50 - percent % 50) / 50));
            b = Math.floor(100 * ((50 - percent % 50) / 50));//0;
            result = 'rgba(' + r + ',' + g + ',' + b + ', 0.9)';
        }
        return result;
    }

    function interpolateData(input, rowLength) {
        const output = [];
        let rowNum = 1;
        for (let n = 0; n < input.length; n += 1) {
            //output.push(n % rowLength);
            if (n % rowLength === 0) {
                output.push((input[n] + input[n + 1]) / 2)            
            } else if (n > 0) {
                output.push((input[n] + input[n - 1]) / 2)
            } else {
                output.push(input[n]);
            }
            
            if ((n + 1) % rowLength === 0) {
                if (input.length - n > rowLength) {
                    for (let r = 1; r <= rowLength * 2 - 1; r++) {
                        const roundedA = ((rowNum - 1) * rowLength) + Math.floor((r - 1) / 2);
                        const roundedB = ((rowNum - 1) * rowLength) + Math.floor((r - 1) / 2);
                        const topA = input[roundedA];
                        const topB = input[roundedB];
                        const roundedC = (rowNum * rowLength) + Math.floor((r - 1) / 2);
                        const roundedD = (rowNum * rowLength) + Math.floor((r - 1) / 2);
                        const bottomA = input[roundedC];
                        const bottomB = input[roundedD];
                        //output.push(0);
                        output.push((topA + topB + bottomA + bottomB) / 4);
                    }
                    rowNum += 1;
                }
                // Do nothing
            } else {
                //output.push(0);
                output.push((input[n] + input[n + 1]) / 2)
            }
        }
        return output;
    }

    function stringPadZero(str,zeros)
    {
      while(str.length<zeros)
      {
        str="0"+str;
      }
      return str;
    }

    function numberFormat(num)
    {
      let pp=1;
      let points=Math.pow(10,pp);
      let xK=Math.round(num*points);
      let point=(xK%points)+"";
      
      let dig=Math.floor(xK/points)+"";
      return stringPadZero(dig,2)+"."+stringPadZero(point,pp);
    }
    
    let mixPix=undefined;

    let frame_counter = 0;
    let connection=undefined;
    let warnFrame=undefined;
    let stillFrameCounter=0;
    let stillHumanCounter=0;
    let stillHumanTemp=0;
    let TC_config={
      warnAudioPlay:false,
      pixSize:3,
      xflip:false,
      rotateIdx:0,
      filterMode:0,
      speedIdx:5,
      tempCalibMult:36.4/30,
      tempCalibOffset:0
    }

    function config_update_UI(config)
    {

      document.getElementById('filterMode_btn').innerText = "Filter:"+config.filterMode;
      document.getElementById('sound_btn').innerText = "SOUND:"+(config.warnAudioPlay?"ON":"OFF");

      
      document.getElementById("speedIdx_slider").value = config.speedIdx;
      document.getElementById("pixSize_slider").value = config.pixSize;


      
      document.getElementById("input_calib_mult").value = config.tempCalibMult;
      document.getElementById("input_calib_add").value = config.tempCalibOffset;
    }    
    
    document.addEventListener('DOMContentLoaded', function() {
      url_setDefault();
      let input_IP_DOM=document.getElementById('input_IP');
      let url = ls_getCamUrl();
      if(url!==undefined && url.length >0)
        input_IP_DOM.value = url;

      {
        let loadConfig = ls_getJson("TC_config");
        if(loadConfig===undefined)loadConfig={};
        TC_config={...TC_config,...loadConfig};
        config_update_UI(TC_config);
      }



      var slider = document.getElementById("speedIdx_slider");

      // Update the current slider value (each time you drag the slider handle)
      slider.oninput = function() {
        
        // output.innerHTML = this.value;
        
        if(connection.readyState==WebSocket.OPEN)
        {
          let spidx=parseInt(this.value);
          connection.send(JSON.stringify({speedIdx:spidx}));
          TC_config.speedIdx=spidx;
          ls_setJson("TC_config",TC_config);
        }
      }


      var ps_slider = document.getElementById("pixSize_slider");

      // Update the current slider value (each time you drag the slider handle)
      ps_slider.oninput = function() {
        
        // output.innerHTML = this.value;
        
        if(connection.readyState==WebSocket.OPEN)
        {
          let vi=parseInt(this.value);
          connection.send(JSON.stringify({pixSize:vi}));
          TC_config.pixSize=vi;
          ls_setJson("TC_config",TC_config);
        }
      }






      var input_calib_mult = document.getElementById("input_calib_mult");
      input_calib_mult.oninput = function() {
        
          let cmult=parseFloat(this.value);
          TC_config.tempCalibMult=cmult;
          ls_setJson("TC_config",TC_config);
      }

      
      var input_calib_add = document.getElementById("input_calib_add");
      input_calib_add.oninput = function() {
        
          let cadd=parseFloat(this.value);
          TC_config.tempCalibOffset=cadd;
          ls_setJson("TC_config",TC_config);
      }
    }, false);

    // Log messages from the server
    let onmessage = function (e) {
        if (e.data.length < 100) {
            return;
        }
        frame_counter += 1;
        let Frame_RMSE=0;
        let isFrameStill=true;
        const values_raw = new Int16Array(e.data);
        if(mixPix===undefined)
        {
          mixPix= new Array(values_raw.length);
          values_raw.forEach((mP,idx) => {
            mixPix[idx]=1.0*mP;
          });
          stillFrameCounter=0;
          
        }
        else
        {
          Frame_RMSE=0;
          switch(TC_config.filterMode)
          {
            case 0:
              
              Frame_RMSE = Math.sqrt(
                mixPix.reduce((s,v,idx)=>s+(v-values_raw[idx])*(v-values_raw[idx]),0)
                  /mixPix.length);

              values_raw.forEach((mP,idx) => {
                mixPix[idx]=1.0*mP;
              });
              if(Frame_RMSE>55)isFrameStill=false;
              break;
            
            case 1:
              mixPix.forEach((mP,idx) => {
                let diff = values_raw[idx]-mP;
                if(diff<0)diff=-diff;
                diff-=50;
                let approachV=diff/100;
                if(approachV>1)approachV=1;
                if(approachV<0.2)approachV=0.2;
                let newPixV=mixPix[idx]+approachV*(values_raw[idx]-mP);
                Frame_RMSE+=(newPixV-mixPix[idx])*(newPixV-mixPix[idx]);
                mixPix[idx]=newPixV;
              });
              Frame_RMSE=Math.sqrt(Frame_RMSE/mixPix.length);
              
              if(Frame_RMSE>20)isFrameStill=false;
              break;
            
            case 2:
              
              mixPix.forEach((mP,idx) => {
                if(values_raw[idx]>mP)
                {
                  mixPix[idx]=values_raw[idx];
                  return;
                }
                let approachV=0.05;
                let newPixV=mixPix[idx]+approachV*(values_raw[idx]-mP);
                Frame_RMSE+=(newPixV-mixPix[idx])*(newPixV-mixPix[idx]);
                mixPix[idx]=newPixV;
              });
              Frame_RMSE=Math.sqrt(Frame_RMSE/mixPix.length);

              if(Frame_RMSE>5)isFrameStill=false;
              break;

            case 3:
              
              
              let rmse = Math.sqrt(
                mixPix.reduce((s,v,idx)=>
                  s+(v-values_raw[idx])*(v-values_raw[idx]),0)/mixPix.length
                  );
              
              rmse-=70;

              rmse/=70;

              if(rmse>1)rmse=1;
              if(rmse<0.1)rmse=0.1;
              let approachV=rmse;
              mixPix.forEach((mP,idx) => {
                let tmpap=approachV;
                if(values_raw[idx]>mP)
                {
                  tmpap=1;
                }
                mixPix[idx]+=tmpap*(values_raw[idx]-mP);
                
                let newPixV=mP+tmpap*(values_raw[idx]-mP);
                Frame_RMSE+=(newPixV-mP)*(newPixV-mP);
                mixPix[idx]=newPixV;
              });
              Frame_RMSE=Math.sqrt(Frame_RMSE/mixPix.length);
              
              if(Frame_RMSE>17)isFrameStill=false;
              break;
          }
        }


        const values=mixPix.map(v=>((v/100.0)*TC_config.tempCalibMult+TC_config.tempCalibOffset));
        const tempValues = values;
        const sortedValues = values.slice().sort();
        // console.log(values);
        let avgHighTemp = 0;
        let avgLowTemp = 0;
        
        let avgTemp = sortedValues.reduce((s,v)=>s+v,0)/sortedValues.length;

        let highCount=4;
        for (let w = sortedValues.length - 1; w > sortedValues.length - 1-highCount; w -= 1) {
            avgHighTemp += sortedValues[w];
        }
        avgHighTemp = avgHighTemp / highCount;

        
        if(isFrameStill)
        {
          if(avgHighTemp>35)stillHumanCounter++;
          stillFrameCounter++;
        }
        else
        { 
          stillFrameCounter=0;
          stillHumanCounter=0;
        }

        avgLowTemp = 0;

        let lowCount=20;
        for (let w = 0; w < lowCount; w += 1) {
            avgLowTemp += sortedValues[w+4];
        }
        avgLowTemp = avgLowTemp / lowCount;
        

        if(stillHumanCounter>0)
        {
          stillHumanTemp+=(avgHighTemp-stillHumanTemp)/(stillHumanCounter);
        }
        else
        {
          stillHumanTemp=0;
        }

        if(stillHumanCounter>5 && TC_config.warnAudioPlay==true && stillHumanTemp>37.5)
        {
          if(warnFrame===undefined)
          {
            warnFrame=frame_counter;
            warn_audio.play();
          }
        }
        else if(frame_counter-warnFrame>40 && warnFrame!==undefined)
        {
          
          if(warnFrame!==undefined)
          {
            warnFrame=undefined;
            warn_audio.pause();
          }
        }
        
        let img_W=32;
        let img_H=24;

        document.getElementById('temperature').innerText = 
          'SHC: '+ stillHumanCounter+'\n TEMP: '+ numberFormat(stillHumanTemp)+" C\n"+
          'H: ' + numberFormat(avgHighTemp) + ' C | L: ' +  numberFormat(avgLowTemp)  + ' C\n'
          'A: ' + numberFormat(avgTemp) + ' C';
        let high = 40;
        let low = 20;

        var c2 = document.getElementById('myCanvas');
        var c2_context = c2.getContext('2d');
        c2_context.font = "40pt Arial";
        let heatMapBarW=10;
        let W=((img_H*TC_config.pixSize)|0)+heatMapBarW;
        let H=(img_W*TC_config.pixSize)|0;

        switch(TC_config.rotateIdx)
        {
          case 0:
          case 2:
            c2.height=H;
            c2.width=W;
          break;
          case 1:
          case 3:

            c2.width=H;
            c2.height=W;
          break;

        }

        for (let i = 0; i < tempValues.length; i += 1) {

            let drawStroke=false;
            
            if(tempValues[i]>37.5)
            {
              
              c2_context.strokeStyle = "#00FFFF";
              drawStroke=true;
            }
            else
            {
            }
            let value = (tempValues[i] - low) / (high - low);
            c2_context.fillStyle = heatMapColorforValue(value);
            // c2_context.fillStyle = heatMapColorforValue2(tempValues[i],low,high);

            

            let xpos = (i/img_W)| 0;
            let ypos = i%img_W;
            let xPos;
            let yPos;
            switch(TC_config.rotateIdx)
            {
              case 0:
                xPos=xpos;
                yPos= ypos;
              break;
              case 1:
                xPos=ypos;
                yPos=img_H-xpos;
              break;
              case 2:
                xPos=img_H-xpos;
                yPos=img_W-ypos;
              break;
              case 3:
                yPos=xpos;
                xPos=img_W-ypos;
              break;

            }
            // console.log(xPos,yPos);
            if(TC_config.xflip==true)
            {
              switch(TC_config.rotateIdx)
              {
                case 0:
                case 2:
                  xPos=img_H-xPos;
                break;
                case 1:
                case 3:
                  xPos=img_W-xPos;
                break;
              }
            }

            c2_context.fillRect(xPos*TC_config.pixSize, yPos*TC_config.pixSize, TC_config.pixSize, TC_config.pixSize);
            if(drawStroke)
              c2_context.strokeRect(xPos*TC_config.pixSize, yPos*TC_config.pixSize, TC_config.pixSize, TC_config.pixSize);
        }

        let drawBlockH=20;
        for (let i = 0; i < c2.height; i += drawBlockH)
        {
          
          c2_context.fillStyle = heatMapColorforValue((c2.height-i)/c2.height);
          c2_context.fillRect(c2.width-heatMapBarW, i, heatMapBarW, drawBlockH);
        }
        
        for (let i = 0; i < c2.height; i += drawBlockH*5)
        {
          
          c2_context.fillStyle = heatMapColorforValue((c2.height-i)/c2.height);
          c2_context.fillRect(c2.width-heatMapBarW, i, heatMapBarW, drawBlockH);
        }
        c2_context.fillStyle = "#FFF";
        c2_context.fillText(high, c2.width-10,20);
        c2_context.fillText(low, c2.width-10,c2.height-10);

    };
    function ws_start()
    {
      if(connection!==undefined)
      {
        ws_stop();
      }
      let input_IP_DOM=document.getElementById('input_IP');
      let start_btn_DOM=document.getElementById('start_btn');
      input_IP_DOM.disabled=true;
      start_btn_DOM.disabled=true;
      let url = 'ws://'+input_IP_DOM.value;

      connection= new WebSocket(url);

      connection.binaryType = "arraybuffer";
      connection.onopen = function () {
        // connection.send('Ping'); // Send the message 'Ping' to the server
        ls_setCamUrl(input_IP_DOM.value);
      };
      connection.onclose = function(event) {
        input_IP_DOM.disabled=
        start_btn_DOM.disabled=false;
        connection=undefined;
        
        warn_audio.pause();
      };
      // Log errors
      connection.onerror = function (error) {
        console.log('WebSocket Error ' + error);
        input_IP_DOM.disabled=
        start_btn_DOM.disabled=false;
        connection=undefined;
        warn_audio.pause();
      };
      connection.onmessage=onmessage;
    }
    function ws_stop()
    {
      
      if(connection==undefined)
      {
        return;
      }
      connection.close();
    }


    
    function flipX() {
      TC_config.xflip=!TC_config.xflip;
      
      ls_setJson("TC_config",TC_config);
    }

    function rotate() {
      TC_config.rotateIdx=(TC_config.rotateIdx+1)%4;
      ls_setJson("TC_config",TC_config);
    }

    function filterMode_toggle() {
      TC_config.filterMode=(TC_config.filterMode+1)%4;
      config_update_UI(TC_config);
      ls_setJson("TC_config",TC_config);
    }

    function SOUND_toggle()
    {
      TC_config.warnAudioPlay=!TC_config.warnAudioPlay;
      warn_audio.pause();
      config_update_UI(TC_config);
      ls_setJson("TC_config",TC_config);

      // if(connection.readyState==WebSocket.OPEN)
      // {
      //   if(TC_config.warnAudioPlay)
      //     connection.send("{\"speedIdx\":5}");
      //   else
      //     connection.send("{\"speedIdx\":3}");

      // }
      
    }

    </script>
</head>
<body class="fullFrame">
    <canvas id='myCanvas' class="left" height='48' width='64' style='border:1px solid #d3d3d3;'></canvas>
    <div class="right">
      <p id='temperature'></p>
      <button class="cButton" onclick='flipX()'>Flip X</button>
      <button class="cButton" onclick='rotate()'>ROTATE</button>
      <br/>
      <button  class="cButton" onclick='SOUND_toggle()'  id="sound_btn">SOUND:OFF</button>
      <button  class="cButton" onclick='filterMode_toggle()'  id="filterMode_btn">Filter:0</button>
      <br/>
      <button  class="cButton" onclick='ws_stop()'  id="stop_btn">STOP</button>
      <button class="cButton" onclick='ws_start()'  id="start_btn">START</button>
      <input type="text" id="input_IP" name="input_IP" value="thermal.local:81">
      <button class="sButton" onclick='url_setDefault()'  id="setUrlDefault_btn">X</button>
      v0.0.1
      <br/>
      SPEED:<input type="range" min="1" max="5" value="5" class="slider" id="speedIdx_slider">
      <br/>
      SIZE :<input type="range" min="1" max="30" value="30" class="slider" id="pixSize_slider">
      <br/>
      -CALIB-<br/>
      
      X<input id="input_calib_mult" type="number"  step="0.01" min="0" max="2">+<input id="input_calib_add" type="number"  step="0.01" min="-20" max="20">

    </div>
</body>

</html>